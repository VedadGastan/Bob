print "========================================"
print "BOB PARALLEL PROGRAMMING BENCHMARK"
print "========================================"
print ""

print "System: " + num_threads() + " CPU threads available"
print ""

print "--- Benchmark 1: Large Sum (0 to 100,000) ---"
print "Computing sum using parallel processing..."

var benchmark_sum = 0
parallel i in 0..100000
    atomic_add("benchmark_sum", i)
end

print "Result: " + benchmark_sum
print "Expected: 4999950000"
print ""

print "--- Benchmark 2: Prime Number Approximation ---"
print "Counting numbers with no small factors (parallel)..."

var prime_count = 0
parallel n in 2..10000
    var is_candidate = 1
    var d = 2
    while d * d <= n
        if n % d == 0
            is_candidate = 0
        end
        d++
    end
    if is_candidate == 1
        atomic_add("prime_count", 1)
    end
end

print "Candidates found: " + prime_count
print ""

print "--- Benchmark 3: Matrix-Style Computation ---"
print "Computing 100x100 matrix sum (parallel)..."

var matrix_result = 0
parallel row in 0..100
    parallel col in 0..100
        atomic_add("matrix_result", row * col)
    end
end

print "Matrix sum: " + matrix_result
print ""

print "--- Benchmark 4: Fibonacci Parallel ---"
print "Computing fibonacci sums in parallel..."

func fib(n)
    if n <= 1
        return n
    end
    return fib(n - 1) + fib(n - 2)
end

var fib_total = 0
parallel i in 1..15
    var f = fib(i)
    atomic_add("fib_total", f)
end

print "Sum of fib(1) to fib(14): " + fib_total
print ""

print "========================================"
print "BENCHMARK COMPLETE"
print "========================================"
print ""
print "Bob's parallel programming allows you to:"
print "- Utilize all CPU cores automatically"
print "- Write clean, simple parallel code"
print "- Use atomic operations for safety"
print "- Scale performance with hardware"